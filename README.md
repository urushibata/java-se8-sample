##Java SE8の新機能の説明とサンプルコード

Java1.5までの基本を理解している人を対象とします。
目安としてはジェネリクスがわかる程度です。

- - -

_新機能リスト_

1. ラムダ式
1. インターフェースの実装
1. 関数型インターフェース
1. メソッド、コンストラクタ参照
1. Stream
1. Optional
1. Mapの拡張
1. 日付API
1. Nashorn（新JavaScript実行エンジン）

- - -

_ラムダ式_

+ ラムダ式は関数型インターフェース（抽象メソッドが1つのみのインターフェース）を実装する簡略化された記述法です。
+ 基本は以下のように書きます。
省略が可能で、通常は省略して書くはずです。

        (メソッドの引数) -> { 処理 }

        // < 例 >
        // 基本
        (String str) -> { System.out.println(str) }

        // 省略した書き方(詳しくはサンプルソースを参照してください)
        str -> System.out.println(str)

+ よくサンプルに使用されるのは匿名クラスの場面ですが、最も力を発揮するのは後述するStream APIを使う場面だと思います。
(匿名クラス自体めったに使わないですし…)
+ ラムダ式の利点は、処理の本当に必要な部分だけ書くことができるというところにあります。

        List<Integer> numbers = Arrays.asList(100, 51, 78, 3, -13, 34);
        // 匿名クラスを使う
        // 1.7まで
        Collections.sort(numbers, new Comparator<Integer>() {
            @Override
            public int compare(Integer n1, Integer n2) {
                return n2 - n1;
            }
        });

        // ラムダ式で同様の処理を書くととてもシンプルになります。
        Collections.sort(numbers, (n1, n2) -> n2 - n1);

        // 説明
        // 1. sort第二引数はComparetor型しかありません。
        // 2. Comparetor型は抽象メソッドが一つ(compare)しかない関数型インターフェースです。
        // 上記より、ラムダ式が実装しているのはcompareだと判断できます。
        // また、引数の型はリストの型パラメータよりInteger型だと判断できます(型推論)。

        // [ 実行結果 ]
        // 100
        // 78
        // 51
        // 34
        // 3
        // -13

+ 簡単ですね。
初めて見ても驚かない程度に知っておくのがよいかと思います。
RubyとかC#とかにもラムダ式があるので、将来役に立つかもしれません。
+ ラムダ式内で参照できる外部変数はfinalな変数か事実上finalな変数のみなので注意が必要です。
つまり、ラムダ式内で外部の変数を変更することはできないということです。
この仕様のため、「Java8のラムダはクロージャではない！」と主張する人もいるようですが、定義付けについて私は言及しません。
+ 変数のスコープはラムダ式外と同じスコープが適用されます。
その為、同スコープ内ラムダ式外の変数と同じ名前の変数を定義するとコンパイルエラーになります。
上の例で言うと、匿名クラス内ではnumbersという変数を定義することができますが、ラムダ式の中では定義することはできません。
+ サンプルコードは/src/main/java/cmds/java/se8/lambda以下にあります。

- - -

_インターフェースの実装_

+ インターフェースも実装をもてるようになりました。
staticメソッドとdefaultメソッドの2パターンあります。
+ defaultメソッドはインスタンスメソッドです。
メソッドの前に『default』と記述します。
インターフェースを実装したクラスでオーバーライドしなくても使用できます。
インターフェースは多重継承可能ですので、これによりMixin(厳密には違う？)が可能になりました。
メソッドがコンフリクトした場合、コンパイルエラーになります。
(注: Mixin …
Mixin とはオブジェクト指向プログラミング言語において、サブクラスによって継承されることにより機能を提供し、単体で動作することを意図しないクラスである。
[wikipedia]
)

        default public String hoge() {
            return "hoge";
        }

+ defaultメソッドの単体テストは、インターフェースを実装したテスト用具象クラスを作って、それをテストする方法を取るのがよいと思います（抽象クラスと同じ要領）。
+ staticメソッドについては、具象クラスと同じ要領です。
+ サンプルコードは/src/main/java/cmds/java/se8/interfaceImpl以下にあります。

- - -

_関数型インターフェース_

+ ラムダ式のところでも書きましたが、「関数型インターフェース = 抽象メソッドが1つのみのインターフェース」です。
+ 関数型インターフェースによってJavascript、PHP、Ruby、Perlのような言語と同じように関数(メソッド)を変数に代入できるようになります。
これを『ファーストクラスファンクション』と言うそうです。
java.util.functionパッケージに標準APIが追加されました。

        // 整数を1 / 2にするメソッドを変数にセット
        // Functionクラスは引数を1つ受け取って、任意の戻り値を持つ関数型インターフェースです。
        Function<Integer, Integer> fnc = i -> i / 2;

        // メソッドを実行
        System.out.println(fnc.apply(51));

        // [ 実行結果 ]
        // 25

+ 関数型インターフェースを表す『@FunctionalInterface』というアノテーションが追加されています。
コンパイル時にその『@FunctionalInterface』を付与したインターフェースが関数型インターフェースの条件を満たしていでない場合、エラーになります。
ですが、アノテーションが無くても関数型インターフェースの条件を満たしていれば、関数型インターフェースとして扱われるので
現時点(Java8u45)では単なる情報目的のためのアノテーションです。
+ サンプルコードは/src/main/java/cmds/java/se8/functionalInterface以下にあります。

- - -

_メソッド、コンストラクタ参照_

+ 当然なのですが、メソッド参照はメソッドへの参照です。
厳密には違うと思いますが、関数オブジェクトのリテラル表記のようなものといったところでしょうか。
記述方法はstaticメソッドの場合「クラス名::メソッド名」、インスタンスメソッドの場合「インスタンス名::メソッド名」です。

        // リストの中を順番に表示する。
        Arrays.asList("co", "mo", "do", " ", "sys", "tem", "!!").stream()
            .forEach(System.out::print);

        // 説明
        // StreamインターフェースのforEachメソッドを見るとわかりますが、このメソッドは
        // 引数にConsumer<? super T> action型を取ります。
        // Consumerクラスは1つの引数を受け取って、void型を返す関数型インターフェースです。
        // System.out.printメソッドはその条件に当てはまるので、メソッド参照で書くことができます。

        // ■では引数はどこから来るのでしょうか？
        // 例の記述はラムダ式で「.forEach(str -> System.out.print(str);」と書くことができます。
        // このラムダ式を見ると、メソッド参照の引数に何が使われているのかがわかります。
        // リストの各要素が順番に引数にセットされているのがわかります。

        // [ 実行結果 ]
        // comodo system!!

+ もちろん、関数型インターフェースに代入可能です。

        Consumer<String> func = System.out::print;

+ 実はインスタンスメソッドも「クラス名::メソッド名」で記述できます。
この場合、別の意味になります。
以下、Oracleの公式ドキュメントのサンプルで説明します。
[参照](http://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html)

        String[] stringArray = { "Barbara", "James", "Mary", "John", "Patricia", "Robert", "Michael", "Linda" };
        Arrays.sort(stringArray, String::compareToIgnoreCase);

+ 上記サンプルの場合、「String::compareToIgnoreCase」は「(a, b) -> a.comparaToIgnoreCase(b)」と同じ意味になるというミラクルが起きます。
なぜそうなるのかはすいませんがわかりません。
ただ、この書き方は思いのほか便利なため、結構な頻度で見られると思います。
JavaBeanを操作する場合、とても便利です。
+ コンストラクタ参照はメソッド参照と同じようなものです。
記述方法は「クラス名::new」です。
コンストラクタは、その引数の数の関数型インターフェースとして扱われます。

        Supplier<Foo> con = Foo::new;
        Foo foo = con.get();

+ サンプルコードは/src/main/java/cmds/java/se8/methoConRef以下にあります。

- - -

_Stream_

+ Streamはコレクションを操作するための新しい仕様です。
イメージ的にはイテレータと同じでコレクションを全て処理するのですが、map、filter、reduceなど便利なメソッドが使用可能です。
**StreamAPIを使用するにはラムダ式の理解が必須です。**
+ 生成処理→中間操作→終端操作の順に記述し、終端操作を行うことでそこまでに書いた中間操作が一度に実行されます(遅延評価)。
+ java.util.streamパッケージに標準APIが追加されました。
+ サンプルコードは/src/main/java/cmds/java/se8/stream以下にあります。

- - -

_Optional_

+ 1.8で新しく追加されたNullの可能性のある値を1つ保持するクラスです。(java.util.Optional)
+ Streamもそうですが、mapやflatMapの演算を連続するような機能を「モナド」?というらしいです。
+ ネットから引用

> まず押さえておくべきことは、モナドは非常に汎用的な機能だということです。数学的定義はともかく、機能的に言うと、一連の処理(計算)を実行するにあたって、ぞれぞれのステップでその入力(引数)と出力(返り値)をキャプチャして、各段階で多様な処理を挟み込み、表面上の計算に対する追加的な別の意味(文脈)を外付けで付与することがモナドの機能です。

+ モナド→ブロックのように部品を組み合わせてプログラミングしていくこと？私はメソッドチェーンで繋げていく事ができるAPIのことだと理解しました。
+ サンプルを書きます。

        // 1.7まで
        if (val != null) {
            System.out.println(val.get());
        }

        // Optionalを使った場合
        // ifPresentはOptionalでラップした値がNullでない場合引数の関数を実行するメソッドです。
        Optional.of(val).ifPresent(System.out::println);

        // Optionalとは関係ありませんが、1.7と1.8はプログラマの技量によって書き方が大きく変わるとこのコードから感じられます。

+ サンプルコードは/src/main/java/cmds/java/se8/optional以下にあります。

- - -

_Mapの拡張_

- - -

_日付API_


- - -

_Nashorn（新JavaScript実行エンジン）_


- - -